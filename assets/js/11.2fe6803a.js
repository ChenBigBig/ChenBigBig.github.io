(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{283:function(r,t,a){"use strict";a.r(t);var n=a(14),v=Object(n.a)({},(function(){var r=this,t=r._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[t("h1",{attrs:{id:"多线程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#多线程"}},[r._v("#")]),r._v(" 多线程")]),r._v(" "),t("h2",{attrs:{id:"什么是程序-什么是线程-什么是进程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是程序-什么是线程-什么是进程"}},[r._v("#")]),r._v(" 什么是程序，什么是线程，什么是进程")]),r._v(" "),t("p",[r._v("程序：为了完成特定任务，编写的指令集合（就是我们平时写的代码）"),t("br"),r._v("\n进程：指操作系统中运行的程序，相当于启动一个应用程序等于启动了一个进程，操作系统会分配对应的内存空间"),t("br"),r._v("\n线程：由进程创建，一个进程可以由多个线程"),t("br"),r._v("\n举个例子：在操作系统下打开腾讯视频软件（进程）播放视频的时候有多个线程同时执行（背景音乐，视频，字幕等）")]),r._v(" "),t("h2",{attrs:{id:"单线程和多线程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#单线程和多线程"}},[r._v("#")]),r._v(" 单线程和多线程")]),r._v(" "),t("p",[r._v("单线程：同一时刻只运行执行一个线程 一个顺序单一执行流程就是一个线程"),t("br"),r._v("\n多线程：同一时刻可以执行多个线程 考虑并发和并行"),t("br"),r._v("\n并发：同一时刻多个任务交替执行，造成一种貌似同时的错觉，单核CPU执行任务的过程就是并发"),t("br"),r._v("\n并行：同一时刻多个任务同时执行，多核CPU支持并行过程")]),r._v(" "),t("h2",{attrs:{id:"多线程的用途"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#多线程的用途"}},[r._v("#")]),r._v(" 多线程的用途")]),r._v(" "),t("p",[r._v("当多个代码片段执行顺序有冲突时候，希望他们相互之间不干扰可以使用多线程技术"),t("br"),r._v("\n一个线程可以运行，但是多个线程可以使执行速度更快可以使用多线程")]),r._v(" "),t("h2",{attrs:{id:"线程的创建"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线程的创建"}},[r._v("#")]),r._v(" 线程的创建")]),r._v(" "),t("p",[r._v("1.继承Thread类，重写Run方法（相当于线程干的活），最后调用start方法"),t("br"),r._v("\n2.实现Runnable接口，重写Run方法，将线程任务传递给Thread，最后调用start方法"),t("br"),r._v("\n3.使用Callable和Future创建线程（继承Callable实现call方法）"),t("br"),r._v("\n4.使用线程池的方式创建"),t("br"),r._v("\n5.使用Spring的异步注解@Async"),t("br"),r._v("\n真正实现多线程方法其实是start0()本地方法,是JVM调用,底层是C/C++实现的")]),r._v(" "),t("h2",{attrs:{id:"线程的常用方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线程的常用方法"}},[r._v("#")]),r._v(" 线程的常用方法")]),r._v(" "),t("p",[r._v("Thread main = Thread.currentThread();//获取当前正在执行的线程"),t("br"),r._v("\nSystem.out.println(main.getName());//获取线程的名字"),t("br"),r._v("\nSystem.out.println(main.getId());//获取线程的唯一标识"),t("br"),r._v("\nSystem.out.println(main.getPriority());//获取线程的优先级"),t("br"),r._v("\nSystem.out.println(main.isInterrupted());//判断线程是否被中断"),t("br"),r._v("\nSystem.out.println(main.isAlive());//判断线程是否活着"),t("br"),r._v("\nSystem.out.println(main.isDaemon());//判断线程是否是守护线程")]),r._v(" "),t("h2",{attrs:{id:"线程安全问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线程安全问题"}},[r._v("#")]),r._v(" 线程安全问题")]),r._v(" "),t("p",[r._v("单线程是不会出现线程安全问题"),t("br"),r._v("\n多个线程没有访问共享数据也不会产生安全问题"),t("br"),r._v("\n当多个线程并发操作同一临界资源，由于线程切换时机不确定，导致操作顺序出现了混乱，产生线程安全问题。"),t("br"),r._v("\n线程安全是不能产生的，需要避免，让一个线程访问共享数据的同时，不论该线程是否失去了CPU的访问权限，\n让其它线程都进行等待，等待当前线程执行完毕后，才能进行操作"),t("br"),r._v("\n为了避免线程安全问题的发生，采用线程同步机制，保证数据在任何同一时刻，最多只有一个线程被访问，保证数据完整性。")]),r._v(" "),t("h2",{attrs:{id:"线程同步"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线程同步"}},[r._v("#")]),r._v(" 线程同步")]),r._v(" "),t("p",[r._v("【解决线程安全问题（两种方法1.同步方法 2.同步代码块）】"),t("br"),r._v("\n1：当一个方法使用synchronized修饰后这个方法称为同步方法,多个线程不能同时在方法内执行,只能按照顺序一个一个执行,有效的解决了安全的问题"),t("br"),r._v("\n2：有效的缩小同步范围可以在保证并发安全的前提下尽可能的提高并发效率.同步块可以更准确的控制需要多个线程排队执行的代码片段.")]),r._v(" "),t("h2",{attrs:{id:"互斥锁和死锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#互斥锁和死锁"}},[r._v("#")]),r._v(" 互斥锁和死锁：")]),r._v(" "),t("p",[r._v("互斥锁：使用多个synchronized锁定多个代码片段时，锁对象都相同时，这些代码片段就是互斥的，多个线程不能同时执行他们\n死锁：以两个线程为例，当两个线程各持有一个锁的过程并且等待对方先释放锁时会形成一种僵持状态导致程序卡住无法继续执行\n避免死锁的方法："),t("br"),r._v("\n1.避免在持有一个锁的同时去等待持有另一个锁(避免synchronized嵌套)"),t("br"),r._v("\n2:当无法避免synchronized嵌套时，就必须保证多个线程锁对象的持有顺序必须一致。即:A线程在持有锁1的过程中去持有锁2时,B线程也要以这样的持有顺序进行。"),t("br"),r._v("\n互斥锁：想象自己的喉咙呼吸和咽口水不能同时进行"),t("br"),r._v("\n死锁：想象推门和进门不能同时进行/南北方人吃饭喝汤问题")]),r._v(" "),t("h2",{attrs:{id:"乐观锁和悲观锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#乐观锁和悲观锁"}},[r._v("#")]),r._v(" 乐观锁和悲观锁：")]),r._v(" "),t("p",[r._v("悲观锁：悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程。"),t("br"),r._v("\n乐观锁：乐观锁总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了（具体方法可以使用版本号机制或 CAS 算法）。")]),r._v(" "),t("p",[r._v("守护线程\n守护线程是为用户线程进行服务的，当线程中的用户线程都执行完毕后，守护线程也随之结束了，GC垃圾回收就是特殊的守护线程。")]),r._v(" "),t("h2",{attrs:{id:"线程的生命周期"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线程的生命周期"}},[r._v("#")]),r._v(" 线程的生命周期")]),r._v(" "),t("p",[r._v("NEW: 初始状态，线程被创建出来但没有被调用 start() 。"),t("br"),r._v("\nRUNNABLE: 运行状态，线程被调用了 start()等待运行的状态。"),t("br"),r._v("\nBLOCKED：阻塞状态，需要等待锁释放。"),t("br"),r._v("\nWAITING：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。"),t("br"),r._v("\nTIME_WAITING：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。"),t("br"),r._v("\nTERMINATED：终止状态，表示该线程已经运行完毕。"),t("br"),r._v(" "),t("img",{attrs:{src:"/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png",alt:"线程的生命周期"}})])])}),[],!1,null,null,null);t.default=v.exports}}]);