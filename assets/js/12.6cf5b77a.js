(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{282:function(t,s,a){"use strict";a.r(s);var e=a(14),r=Object(e.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"mybatis篇"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#mybatis篇"}},[t._v("#")]),t._v(" Mybatis篇")]),t._v(" "),s("h2",{attrs:{id:"mybatis是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#mybatis是什么"}},[t._v("#")]),t._v(" Mybatis是什么？")]),t._v(" "),s("p",[t._v("1.MyBatis框架是一个开源的数据持久层框架。"),s("br"),t._v("\n2.它的内部封装了通过JDBC访问数据库的操作，支持普通的SQL查询、存储过程和高级映射，几乎消除了所有的JDBC代码和参数的手工设置以及结果集的检索。"),s("br"),t._v("\n3.MyBatis作为持久层框架，其主要思想是将程序中的大量SQL语句剥离出来，配置在配置文件当中，实现SQL的灵活配置。"),s("br"),t._v("\n4.这样做的好处是将SQL与程序代码分离，可以在不修改代码的情况下，直接在配置文件当中修改SQL。")]),t._v(" "),s("h2",{attrs:{id:"mybatis的工作原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#mybatis的工作原理"}},[t._v("#")]),t._v(" Mybatis的工作原理")]),t._v(" "),s("p",[t._v("1.读取MyBatis配置文件：mybatis-config.xml为MyBatis的全局配置文件，配置了MyBatis的运行环境等信息，例如数据库连接信息。"),s("br"),t._v("\n2.加载映射文件。映射文件即SQL映射文件，该文件中配置了操作数据库的SQL语句，需要在MyBatis配置文件mybatis-config.xml中加载。mybatis-config.xml文件可以加载多个映射文件，每个文件对应数据库中的一张表。"),s("br"),t._v("\n3.构造会话工厂：通过MyBatis的环境等配置信息构建会话工厂SqlSessionFactory。"),s("br"),t._v("\n4.创建会话对象：由会话工厂创建SqlSession对象，该对象中包含了执行SQL语句的所有方法。"),s("br"),t._v("\n5.Executor执行器：MyBatis底层定义了一个Executor 接口来操作数据库，它将根据SqlSession传递的参数动态地生成需要执行的SQL语句，同时负责查询缓存的维护。"),s("br"),t._v("\n6.MappedStatement 对象：在Executor接口的执行方法中有一个MappedStatement类型的参数，该参数是对映射信息的封装，用于存储要映射的SQL语句的id、参数等信息。输入参数映射："),s("br"),t._v("\n7.输入参数类型可以是Map、List等集合类型，也可以是基本数据类型和POJO类型。输入参数映射过程类似于 JDBC对preparedStatement对象设置参数的过程。"),s("br"),t._v("\n8.输出结果映射：输出结果类型可以是Map、List等集合类型，也可以是基本数据类型和POJO类型。输出结果映射过程类似于 JDBC对结果集的解析过程。")]),t._v(" "),s("h2",{attrs:{id:"mybatis中接口绑定有几种实现方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#mybatis中接口绑定有几种实现方式"}},[t._v("#")]),t._v(" MyBatis中接口绑定有几种实现方式?")]),t._v(" "),s("p",[t._v("1.通过注解绑定，在接口的方法上面加上 @Select@Update等注解里面包含Sql语句来绑定（SQL语句比较简单的时候，推荐注解绑定）"),s("br"),t._v("\n2.通过xml里面写SQL来绑定, 指定xml映射文件里面的namespace必须为接口的全路径名（SQL语句比较复杂的时候，推荐xml绑定）")]),t._v(" "),s("h2",{attrs:{id:"和-的区别是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#和-的区别是什么"}},[t._v("#")]),t._v(" #{}和${}的区别是什么？")]),t._v(" "),s("div",{staticClass:"language-sql extra-class"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#{ } 被解析成预编译语句，预编译之后可以直接执行，不需要重新编译sql。")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//sqlMap 中如下的 sql 语句")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("select")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("user")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("where")]),t._v(" name "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#{name};")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//解析成为预编译语句；编译好SQL语句再取值")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("select")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("user")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("where")]),t._v(" name "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" ?"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n${ } 仅仅为一个字符串替换，每次执行"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("sql")]),t._v("之前需要进行编译，存在 "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("sql")]),t._v(" 注入问题。\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("select")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("user")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("where")]),t._v(" name "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'${name}'")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('//传递的参数为 "ruhua" 时,解析为如下，然后发送数据库服务器进行编译。取值以后再去编译SQL语句。')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("select")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("user")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("where")]),t._v(" name "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"ruhua"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#{}是占位符，预编译处理；${}是拼接符，字符串替换，没有预编译处理。")]),t._v("\nMybatis在处理"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#{}时，#{}传入参数是以字符串传入，会将SQL中的#{}替换为?号，调用PreparedStatement的set方法来赋值。")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#{} 可以有效的防止SQL注入，提高系统安全性；${} 不能防止SQL 注入")]),t._v("\n")])])]),s("h2",{attrs:{id:"一级缓存和二级缓存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一级缓存和二级缓存"}},[t._v("#")]),t._v(" 一级缓存和二级缓存")]),t._v(" "),s("p",[t._v("MyBatis是一种轻量级Java持久化框架。它提供了一级缓存和二级缓存两种缓存机制，下面是这两种缓存机制的区别：")]),t._v(" "),s("ol",[s("li",[t._v("一级缓存："),s("br"),t._v("\n一级缓存也称为本地缓存，它是MyBatis中默认开启的缓存机制。一级缓存是指在同一次会话中，对同一条SQL语句的查询结果进行缓存，当再次查询同一条SQL语句时，直接从缓存中获取结果，减少数据库的访问次数。一级缓存是MyBatis中默认开启的缓存机制，只在当前会话中有效。当会话结束后，一级缓存也将被清空，需要重新查询数据库。")]),t._v(" "),s("li",[t._v("二级缓存："),s("br"),t._v("\n二级缓存是指在多个会话中可以共享的缓存。它是一个全局缓存，可以在多个session之间共享缓存数据。二级缓存需要等待一级缓存失效后才能生效，适用于多个会话的情况下，对于相同的SQL语句，直接从缓存中获取结果，减少数据库的访问次数，提高了查询效率。二级缓存需要在MyBatis配置文件中进行配置，可以使用Ehcache、redis等第三方缓存工具来实现。"),s("br"),t._v("\n总的来说，一级缓存是在会话级别下的缓存，生命周期短，只用于一次会话中；而二级缓存是多个会话之间共享的缓存，是一个全局缓存，生命周期长，可用于多次会话中，需要进行手动的配置。")])]),t._v(" "),s("div",{staticClass:"language-xml extra-class"},[s("pre",{pre:!0,attrs:{class:"language-xml"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("\x3c!-- 通知 MyBatis 框架开启二级缓存 --\x3e")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("settings")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("setting")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("name")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[s("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("cacheEnabled"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("value")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[s("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("true"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("/>")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("settings")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n")])])])])}),[],!1,null,null,null);s.default=r.exports}}]);