(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{284:function(a,n,t){"use strict";t.r(n);var r=t(14),e=Object(r.a)({},(function(){var a=this,n=a._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[n("h1",{attrs:{id:"spring篇"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#spring篇"}},[a._v("#")]),a._v(" Spring篇")]),a._v(" "),n("h2",{attrs:{id:"什么是spring框架"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#什么是spring框架"}},[a._v("#")]),a._v(" 什么是Spring框架")]),a._v(" "),n("p",[a._v("Spring 是一款开源的轻量级 Java 开发框架，旨在提高开发人员的开发效率以及系统的可维护性。"),n("br"),a._v("\nSpring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发，比如说 Spring 支持 IoC（Inversion of Control:控制反转） 和 AOP(Aspect-Oriented Programming:面向切面编程)、可以很方便地对数据库进行访问、可以很方便地集成第三方组件（电子邮件，任务，调度，缓存等等）、对单元测试支持比较好、支持 RESTful Java 应用程序的开发。"),n("br"),a._v("\nSpring 最核心的思想就是不重新造轮子，开箱即用，提高开发效率。")]),a._v(" "),n("h2",{attrs:{id:"spring-ioc-谈谈对spring-ioc的理解"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#spring-ioc-谈谈对spring-ioc的理解"}},[a._v("#")]),a._v(" Spring IOC 谈谈对Spring IOC的理解")]),a._v(" "),n("p",[a._v("Spring IOC是在Spring框架中的一种设计模式，即控制反转（Inversion of Control）。简单来说，控制反转就是把对象的创建和依赖注入的过程交给Spring容器来完成，而不是由开发者自己去手动创建对象。开发者只需要在需要使用这些对象的地方引用它们即可，这样可以大大降低代码的耦合度，提高代码的可维护性和复用性。"),n("br"),a._v("\n在Spring IOC中，开发者只需要通过配置文件或注解方式告诉Spring容器需要创建哪些Bean，并且如何注入它们之间的依赖关系。Spring容器会根据这些配置信息自动创建Bean，并将它们注入到需要使用它们的地方。"),n("br"),a._v("\n总之，Spring IOC的核心思想是通过控制反转来降低代码的耦合度，提高代码的可维护性和复用性。这也是Spring框架能够成为Java企业级应用开发的主流框架之一的原因。")]),a._v(" "),n("h2",{attrs:{id:"什么是依赖注入"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#什么是依赖注入"}},[a._v("#")]),a._v(" 什么是依赖注入")]),a._v(" "),n("p",[a._v("在Spring创建对象的过程中，把对象依赖的属性注入到对象中。依赖注入主要有两种方式：构造器注入和属性注入。")]),a._v(" "),n("h2",{attrs:{id:"bean注入容器有哪些方式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#bean注入容器有哪些方式"}},[a._v("#")]),a._v(" Bean注入容器有哪些方式")]),a._v(" "),n("p",[a._v("1.@configuration+@bean:@Configuration用来声明一个配置类，然后使用 @Bean 注解，用于声明一个bean，将其加入到Spring容器中。"),n("br"),a._v("\n2.通过包扫描特定注解的方式:@ComponentScan放置在我们的配置类上，然后可以指定一个路径，进行扫描带有特定注解的bean，然后加至容器中。[特定注解包括@Controller、@Service、@Repository、@Component]"),n("br"),a._v("\n3:@Import注解导入:@Import注解平时开发用的不多，但是也是非常重要的，在进行Spring扩展时经常会用到，它经常搭配自定义注解进行使用，然后往容器中导入一个配置文件。"),n("br"),a._v("\n4:实现BeanDefinitionRegistryPostProcessor进行后置处理。"),n("br"),a._v("\n5:使用FactoryBean接口")]),a._v(" "),n("h2",{attrs:{id:"将一个类声明为bean的注解有哪些"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#将一个类声明为bean的注解有哪些"}},[a._v("#")]),a._v(" 将一个类声明为Bean的注解有哪些")]),a._v(" "),n("p",[a._v("1.Spring Bean：Bean代指的就是那些被IoC容器所管理的对象。"),n("br"),a._v("\n2.声明Bean的注解有以下这些"),n("br"),a._v("\n@Component：通用的注解，可标注任意类为 Spring 组件。如果一个 Bean 不知道属于哪个层，可以使用@Component 注解标注。"),n("br"),a._v("\n@Repository : 对应持久层即 Dao 层，主要用于数据库相关操作。"),n("br"),a._v("\n@Service : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。"),n("br"),a._v("\n@Controller : 对应 Spring MVC 控制层，主要用于接受用户请求并调用 Service 层返回数据给前端页面。")]),a._v(" "),n("h2",{attrs:{id:"component、-controller、-repositor和-service-的区别"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#component、-controller、-repositor和-service-的区别"}},[a._v("#")]),a._v(" @Component、@Controller、@Repositor和@Service 的区别？")]),a._v(" "),n("p",[a._v("@Component：最普通的组件，可以被注入到spring容器进行管理。"),n("br"),a._v("\n@Controller：将类标记为 Spring Web MVC 控制器。"),n("br"),a._v("\n@Service：将类标记为业务层组件。"),n("br"),a._v("\n@Repository：将类标记为数据访问组件，即DAO组件。")]),a._v(" "),n("h2",{attrs:{id:"component-和-bean-的区别是什么"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#component-和-bean-的区别是什么"}},[a._v("#")]),a._v(" @Component 和 @Bean 的区别是什么？")]),a._v(" "),n("p",[a._v("1:@Component 注解作用于类，而@Bean注解作用于方法。"),n("br"),a._v("\n2:@Component通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中（我们可以使用 @ComponentScan 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。@Bean 注解通常是我们在标有该注解的方法中定义产生这个 bean,@Bean告诉了 Spring 这是某个类的实例，当我需要用它的时候还给我。"),n("br"),a._v("\n3:@Bean 注解比 @Component 注解的自定义性更强，而且很多地方我们只能通过 @Bean 注解来注册 bean。比如当我们引用第三方库中的类需要装配到 Spring容器时，则只能通过 @Bean来实现。")]),a._v(" "),n("h2",{attrs:{id:"注入bean的注解有哪些-autowired和-resource的区别是什么"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#注入bean的注解有哪些-autowired和-resource的区别是什么"}},[a._v("#")]),a._v(" 注入Bean的注解有哪些（@Autowired和@Resource的区别是什么）")]),a._v(" "),n("p",[a._v("注入Bean的注解最主要的由两个（@Autowired或者@Resource）或者@Inject"),n("br"),a._v("\n1:@Autowired 是 Spring 提供的注解，@Resource 是 JDK 提供的注解。"),n("br"),a._v("\n2:@Autowired 默认的注入方式为byType（根据类型进行匹配），@Resource默认注入方式为 byName（根据名称进行匹配）。"),n("br"),a._v("\n3:当一个接口存在多个实现类的情况下，@Autowired 和@Resource都需要通过名称才能正确匹配到对应的 Bean。Autowired 可以通过 @Qualifier 注解来显式指定名称，@Resource可以通过 name 属性来显式指定名称。")]),a._v(" "),n("div",{staticClass:"language-java extra-class"},[n("pre",{pre:!0,attrs:{class:"language-java"}},[n("code",[a._v("举个例子，"),n("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("SmsService")]),a._v(" 接口有两个实现类"),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("SmsServiceImpl1")]),a._v("和 "),n("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("SmsServiceImpl2")]),a._v("，且它们都已经被 "),n("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Spring")]),a._v(" 容器所管理\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 报错，byName 和 byType 都无法匹配到 bean")]),a._v("\n"),n("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[a._v("@Autowired")]),a._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("SmsService")]),a._v(" smsService"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 正确注入 SmsServiceImpl1 对象对应的 bean")]),a._v("\n"),n("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[a._v("@Autowired")]),a._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("SmsService")]),a._v(" smsServiceImpl1"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 正确注入  SmsServiceImpl1 对象对应的 bean")]),a._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// smsServiceImpl1 就是我们上面所说的名称")]),a._v("\n"),n("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[a._v("@Autowired")]),a._v("\n"),n("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[a._v("@Qualifier")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("value "),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[a._v('"smsServiceImpl1"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("SmsService")]),a._v(" smsService"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])]),n("h2",{attrs:{id:"bean的作用域-如何配置bean的作用域"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#bean的作用域-如何配置bean的作用域"}},[a._v("#")]),a._v(" Bean的作用域（如何配置Bean的作用域）")]),a._v(" "),n("p",[a._v("singleton : IoC 容器中只有唯一的 bean 实例。Spring 中的 bean 默认都是单例的，是对单例设计模式的应用。"),n("br"),a._v("\nprototype : 每次获取都会创建一个新的 bean 实例。也就是说，连续 getBean() 两次，得到的是不同的 Bean 实例。")]),a._v(" "),n("div",{staticClass:"language-java extra-class"},[n("pre",{pre:!0,attrs:{class:"language-java"}},[n("code",[n("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//xml方式")]),a._v("\n"),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),a._v("bean id"),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),n("span",{pre:!0,attrs:{class:"token string"}},[a._v('"..."')]),a._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),n("span",{pre:!0,attrs:{class:"token string"}},[a._v('"..."')]),a._v(" scope"),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),n("span",{pre:!0,attrs:{class:"token string"}},[a._v('"singleton"')]),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),a._v("bean"),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v("   \n")])])]),n("div",{staticClass:"language-java extra-class"},[n("pre",{pre:!0,attrs:{class:"language-java"}},[n("code",[n("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//注解方式")]),a._v("\n"),n("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[a._v("@Bean")]),a._v("  \n"),n("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[a._v("@Scope")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("value "),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("ConfigurableBeanFactory")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),n("span",{pre:!0,attrs:{class:"token constant"}},[a._v("SCOPE_PROTOTYPE")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("  \n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Person")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[a._v("personPrototype")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("     \n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Person")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("  \n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("  \n")])])]),n("h2",{attrs:{id:"谈谈对spring-aop的理解"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#谈谈对spring-aop的理解"}},[a._v("#")]),a._v(" 谈谈对Spring AOP的理解")]),a._v(" "),n("p",[a._v("AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。")]),a._v(" "),n("h2",{attrs:{id:"aop专业术语"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#aop专业术语"}},[a._v("#")]),a._v(" Aop专业术语")]),a._v(" "),n("p",[n("img",{attrs:{src:"/aop%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD.png",alt:"aop专业术语"}})]),a._v(" "),n("h2",{attrs:{id:"aspectj-定义的通知类型有哪些"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#aspectj-定义的通知类型有哪些"}},[a._v("#")]),a._v(" AspectJ 定义的通知类型有哪些？")]),a._v(" "),n("p",[a._v("1.Before（前置通知）：目标对象的方法调用之前触发"),n("br"),a._v("\n2.After （后置通知）：目标对象的方法调用之后触发"),n("br"),a._v("\n3.AfterReturning（返回通知）：目标对象的方法调用完成，在返回结果值之后触发"),n("br"),a._v("\n4.AfterThrowing（异常通知）：目标对象的方法运行中抛出 / 触发异常后触发。AfterReturning 和 AfterThrowing 两者互斥。如果方法调用成功无异常，则会有返回值；如果方法抛出了异常，则不会有返回值。"),n("br"),a._v("\n5.Around （环绕通知）：编程式控制目标对象的方法调用。环绕通知是所有通知类型中可操作范围最大的一种，因为它可以直接拿到目标对象，以及要执行的方法，所以环绕通知可以任意的在目标对象的方法调用前后搞事，甚至不调用目标对象的方法")]),a._v(" "),n("h2",{attrs:{id:"spring-框架中用到了哪些设计模式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#spring-框架中用到了哪些设计模式"}},[a._v("#")]),a._v(" Spring 框架中用到了哪些设计模式？")]),a._v(" "),n("p",[a._v("1.简单工厂模式：BeanFactory就是简单工厂模式的体现，根据传入一个唯一标识来获得 Bean 对象。"),n("br"),a._v("\n2.单例模式：一个类仅有一个实例，提供一个访问它的全局访问点。Spring 创建 Bean 实例默认是单例的。"),n("br"),a._v("\n3.适配器模式：SpringMVC中的适配器HandlerAdatper。由于应用会有多个Controller实现，如果需要直接调用Controller方法，那么需要先判断是由哪一个Controller处理请求，然后调用相应的方法。当增加新的 Controller，需要修改原来的逻辑，违反了开闭原则（对修改关闭，对扩展开放）。"),n("br"),a._v("\n4.代理模式：spring 的 aop 使用了动态代理，有两种方式JdkDynamicAopProxy和Cglib2AopProxy。"),n("br"),a._v("\n5.观察者模式：spring 中 observer 模式常用的地方是 listener 的实现，如ApplicationListener。"),n("br"),a._v("\n6.模版模式：Spring 中 jdbcTemplate、hibernateTemplate 等，就使用到了模板模式。"),n("br"),a._v("\n7.工厂方法模式：FactoryBean就是典型的工厂方法模式。spring在使用getBean()调用获得该bean时，会自动调用该bean的getObject()方法。每个 Bean 都会对应一个 FactoryBean，如 SqlSessionFactory 对应 SqlSessionFactoryBean。")]),a._v(" "),n("h2",{attrs:{id:"spring事务实现方式有哪些"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#spring事务实现方式有哪些"}},[a._v("#")]),a._v(" Spring事务实现方式有哪些")]),a._v(" "),n("p",[a._v("Spring事务机制主要包括声明式事务和编程式事务。"),n("br"),a._v("\n1.编程式事务：通过编程的方式管理事务，这种方式带来了很大的灵活性，但很难维护。"),n("br"),a._v("\n2.声明式事务：将事务管理代码从业务方法中分离出来，通过aop进行封装。Spring声明式事务使得我们无需要去处理获得连接、关闭连接、事务提交和回滚等这些操作。使用 @Transactional 注解开启声明式事务。")])])}),[],!1,null,null,null);n.default=e.exports}}]);