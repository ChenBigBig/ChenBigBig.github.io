(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{289:function(r,e,t){"use strict";t.r(e);var a=t(14),n=Object(a.a)({},(function(){var r=this,e=r._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[e("h1",{attrs:{id:"spring-mvc篇"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#spring-mvc篇"}},[r._v("#")]),r._v(" Spring MVC篇")]),r._v(" "),e("h2",{attrs:{id:"说说你对spring-mvc的理解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#说说你对spring-mvc的理解"}},[r._v("#")]),r._v(" 说说你对Spring MVC的理解")]),r._v(" "),e("p",[r._v("SpringMVC是一种基于 Java 的实现MVC设计模型的请求驱动类型的轻量级Web框架，属于Spring框架的一个模块。\n它通过一套注解，让一个简单的Java类成为处理请求的控制器，而无须实现任何接口。同时它还支持RESTful编程风格的请求。")]),r._v(" "),e("h2",{attrs:{id:"spring-mvc的优点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#spring-mvc的优点"}},[r._v("#")]),r._v(" Spring MVC的优点")]),r._v(" "),e("p",[r._v("1.与Spring集成使用非常方便，生态好。"),e("br"),r._v("\n2.配置简单，快速上手。"),e("br"),r._v("\n3.支持 RESTful 风格。"),e("br"),r._v("\n4.支持各种视图技术，支持各种请求资源映射策略。")]),r._v(" "),e("h2",{attrs:{id:"spring-mvc的工作原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#spring-mvc的工作原理"}},[r._v("#")]),r._v(" Spring MVC的工作原理")]),r._v(" "),e("p",[r._v("客户端向服务端发送一次请求，这个请求会先到前端控制器 DispatcherServlet(也叫中央控制器)。"),e("br"),r._v("\nDispatcherServlet 接收到请求后会调用 HandlerMapping 处理器映射器。由此得知，该请求该由哪个 Controller 来处理（并未调用 Controller，只是得知）"),e("br"),r._v("\nDispatcherServlet 调用 HandlerAdapter 处理器适配器，告诉处理器适配器应该要去执行哪个 Controller"),e("br"),r._v("\nHandlerAdapter 处理器适配器去执行 Controller 并得到 ModelAndView(数据和视图)，并层层返回给 DispatcherServlet"),e("br"),r._v("\nDispatcherServlet 将 ModelAndView 交给 ViewReslover 视图解析器解析，然后返回真正的视图。"),e("br"),r._v("\nDispatcherServlet 将模型数据填充到视图中"),e("br"),r._v("\nDispatcherServlet 将结果响应给客户端"),e("br"),r._v(" "),e("img",{attrs:{src:"/SpringMVC%E5%B7%A5%E4%BD%9C%E6%B5%81.png",alt:"SpringMVC工作流"}})]),r._v(" "),e("h2",{attrs:{id:"spring-mvc的常用注解有哪些"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#spring-mvc的常用注解有哪些"}},[r._v("#")]),r._v(" Spring MVC的常用注解有哪些")]),r._v(" "),e("p",[r._v("@Controller：用于标识此类的实例是一个控制器。"),e("br"),r._v("\n@RequestMapping：映射Web请求（访问路径和参数）。"),e("br"),r._v("\n@ResponseBody：注解返回数据而不是返回页面@RequestBody：注解实现接收 http 请求的 json 数据，将 json 数据转换为 java 对象。@PathVariable：获得URL中路径变量中的值"),e("br"),r._v("\n@RestController@Controller+@ResponseBody"),e("br"),r._v("\n@ExceptionHandler标识一个方法为全局异常处理的方法。")]),r._v(" "),e("h2",{attrs:{id:"controller-注解有什么用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#controller-注解有什么用"}},[r._v("#")]),r._v(" @Controller 注解有什么用？")]),r._v(" "),e("p",[r._v("@Controller 注解标记一个类为 Spring Web MVC 控制器。"),e("br"),r._v("\nSpring MVC 会将扫描到该注解的类，然后扫描这个类下面带有 @RequestMapping 注解的方法，根据注解信息，为这个方法生成一个对应的处理器对象。")]),r._v(" "),e("h2",{attrs:{id:"requestmapping-注解有什么用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#requestmapping-注解有什么用"}},[r._v("#")]),r._v(" @RequestMapping 注解有什么用？")]),r._v(" "),e("p",[r._v("@RequestMapping 注解，用于配置处理器的 HTTP 请求方法，URI等信息，这样才能将请求和方法进行映射。这个注解可以作用于类上面，也可以作用于方法上面，在类上面一般是配置这个控制器的 URI 前缀。")]),r._v(" "),e("h2",{attrs:{id:"restcontroller-和-controller-有什么区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#restcontroller-和-controller-有什么区别"}},[r._v("#")]),r._v(" @RestController 和 @Controller 有什么区别？")]),r._v(" "),e("p",[r._v("@RestController 注解，在 @Controller 基础上，增加了 @ResponseBody 注解，更加适合目前前后端分离的架构下，提供 Restful API ，返回 JSON 数据格式。")]),r._v(" "),e("h2",{attrs:{id:"requestmapping-和-getmapping-注解有什么不同"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#requestmapping-和-getmapping-注解有什么不同"}},[r._v("#")]),r._v(" @RequestMapping 和 @GetMapping 注解有什么不同？")]),r._v(" "),e("p",[r._v("1:@RequestMapping：可注解在类和方法上；@GetMapping 仅可注册在方法上"),e("br"),r._v("\n2:@RequestMapping：可进行 GET、POST、PUT、DELETE 等请求方法；@GetMapping 是 @RequestMapping 的 GET 请求方法的特例。")]),r._v(" "),e("h2",{attrs:{id:"requestparam-和-pathvariable-两个注解的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#requestparam-和-pathvariable-两个注解的区别"}},[r._v("#")]),r._v(" @RequestParam 和 @PathVariable 两个注解的区别")]),r._v(" "),e("p",[r._v("两个注解都用于方法参数，获取参数值的方式不同"),e("br"),r._v("\n@RequestParam 注解的参数从请求携带的参数中获取\n@PathVariable 注解从请求的 URI 中获取")]),r._v(" "),e("h2",{attrs:{id:"requestbody和-requestparam的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#requestbody和-requestparam的区别"}},[r._v("#")]),r._v(" @RequestBody和@RequestParam的区别")]),r._v(" "),e("p",[r._v('@RequestBody一般处理的是在ajax请求中声明contentType: "application/json; charset=utf-8"时候。也就是json数据或者xml数据。'),e("br"),r._v("\n@RequestParam一般就是在ajax里面没有声明contentType的时候，为默认的x-www-form-urlencoded格式时。")]),r._v(" "),e("h2",{attrs:{id:"介绍下-spring-mvc-拦截器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#介绍下-spring-mvc-拦截器"}},[r._v("#")]),r._v(" 介绍下 Spring MVC 拦截器")]),r._v(" "),e("p",[r._v("Spring MVC 拦截器对应HandlerInterceor接口，该接口位于org.springframework.web.servlet的包中，定义了三个方法，若要实现该接口，就要实现其三个方法："),e("br"),r._v("\n1:前置处理（preHandle()方法）：该方法在执行控制器方法之前执行。返回值为Boolean类型，如果返回false，表示拦截请求，不再向下执行，如果返回true，表示放行，程序继续向下执行（如果后面没有其他Interceptor，就会执行controller方法）。所以此方法可对请求进行判断，决定程序是否继续执行，或者进行一些初始化操作及对请求进行预处理。"),e("br"),r._v("\n2:后置处理（postHandle()方法）：该方法在执行控制器方法调用之后，且在返回ModelAndView之前执行。由于该方法会在DispatcherServlet进行返回视图渲染之前被调用，所以此方法多被用于处理返回的视图，可通过此方法对请求域中的模型和视图做进一步的修改。"),e("br"),r._v("\n3:已完成处理（afterCompletion()方法）：该方法在执行完控制器之后执行，由于是在Controller方法执行完毕后执行该方法，所以该方法适合进行一些资源清理，记录日志信息等处理操作。")]),r._v(" "),e("h2",{attrs:{id:"spring-mvc中的拦截器和filter的过滤器有什么不同"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#spring-mvc中的拦截器和filter的过滤器有什么不同"}},[r._v("#")]),r._v(" Spring MVC中的拦截器和Filter的过滤器有什么不同")]),r._v(" "),e("p",[r._v("功能相同：拦截器和 Filter 都能实现相应的功能容器不同："),e("br"),r._v("\n拦截器构建在 Spring MVC 体系中；Filter 构建在 Servlet 容器之上"),e("br"),r._v("\n使用便利性不同：拦截器提供了三个方法，分别在不同的时机执行；过滤器仅提供一个方法")]),r._v(" "),e("ol",[e("li",[r._v("拦截器是基于Java的反射机制，它可以拦截请求，并在请求到达Controller之前或之后进行预处理或后处理，例如：记录日志、权限验证、设置请求属性等。而Filter则是基于Servlet规范，可以在请求到达Web容器之前或之后进行预处理或后处理，例如：字符编码格式化、文件压缩、设置请求头等。")]),r._v(" "),e("li",[r._v("拦截器只能对Controller层发出的请求进行拦截，不能对其他的组件如JSP、HTML等进行拦截。而Filter则可以对所有的请求进行拦截，包括静态资源的请求。")]),r._v(" "),e("li",[r._v("拦截器可以在单个Handler内进行链式调用，可以控制拦截器的执行顺序，也可以按照某种规则来进行拦截器的排除，例如：排除静态资源的拦截。而Filter的过滤器只能通过Web.xml文件的配置来进行顺序控制，无法进行灵活的排除。"),e("br"),r._v("\n[总的来说，拦截器和Filter都可以实现请求过滤，但是它们各有优缺点，需要根据具体场景进行选择。一般来说，优先考虑使用拦截器，因为它更加灵活，而Filter则主要是处理一些与请求相关的底层问题，例如字符编码，文件压缩等。]")])]),r._v(" "),e("h2",{attrs:{id:"使用rest风格有什么优势"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用rest风格有什么优势"}},[r._v("#")]),r._v(" 使用REST风格有什么优势")]),r._v(" "),e("p",[r._v("第一，风格统一了，不会出现delUser/deleteUser/removeUser各种命名的代码了。"),e("br"),r._v("\n第二，面向资源，一目了然，具有自解释性。"),e("br"),r._v("\n第三，充分利用 HTTP 协议本身语义。")]),r._v(" "),e("h2",{attrs:{id:"spring-mvc的异常处理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#spring-mvc的异常处理"}},[r._v("#")]),r._v(" Spring MVC的异常处理")]),r._v(" "),e("p",[r._v("可以将异常抛给Spring框架，由Spring框架来处理；我们只需要配置简单的异常处理器，在异常处理器中添视图页面即可。")]),r._v(" "),e("ol",[e("li",[r._v("使用 @ExceptionHandler 注解：在控制器中定义一个方法，并使用 @ExceptionHandler 注解来捕获异常，并进行相应的处理。类上标注@ControllerAdvice")]),r._v(" "),e("li",[r._v("实现 HandlerExceptionResolver 接口：通过实现该接口中的 resolveException() 方法，在全局范围内处理异常。")])])])}),[],!1,null,null,null);e.default=n.exports}}]);