(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{291:function(a,t,v){"use strict";v.r(t);var _=v(14),r=Object(_.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"消息队列【rabbitmq】"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#消息队列【rabbitmq】"}},[a._v("#")]),a._v(" 消息队列【RabbitMQ】")]),a._v(" "),t("h2",{attrs:{id:"什么是mq"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是mq"}},[a._v("#")]),a._v(" 什么是MQ")]),a._v(" "),t("p",[a._v("MQ就是消息队列。是软件和软件进行通信的中间件产品")]),a._v(" "),t("h2",{attrs:{id:"mq的优点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mq的优点"}},[a._v("#")]),a._v(" MQ的优点")]),a._v(" "),t("p",[a._v("异步处理 - 相比于传统的串行、并行方式，提高了系统吞吐量。"),t("br"),a._v("\n应用解耦 - 系统间通过消息通信，不用关心其他系统的处理。"),t("br"),a._v("\n流量削锋 - 可以通过消息队列长度控制请求量；可以缓解短时间内的高并发请求。"),t("br"),a._v("\n日志处理 - 解决大量日志传输。"),t("br"),a._v("\n消息通讯 - 消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如实现点对点消息队列，或者聊天室等。")]),a._v(" "),t("h2",{attrs:{id:"解耦、异步、削峰是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解耦、异步、削峰是什么"}},[a._v("#")]),a._v(" 解耦、异步、削峰是什么？")]),a._v(" "),t("p",[t("strong",[a._v("解耦")]),a._v("：A 系统发送数据到 BCD 三个系统，通过接口调用发送。如果 E 系统也要这个数据呢？那如果 C 系统现在不需要了呢？A 系统负责人几乎崩溃…A 系统跟其它各种乱七八糟的系统严重耦合，A 系统产生一条比较关键的数据，很多系统都需要 A 系统将这个数据发送过来。如果使用 MQ，A 系统产生一条数据，发送到 MQ 里面去，哪个系统需要数据自己去 MQ 里面消费。如果新系统需要数据，直接从 MQ 里消费即可；如果某个系统不需要这条数据了，就取消对 MQ 消息的消费即可。这样下来，A 系统压根儿不需要去考虑要给谁发送数据，不需要维护这个代码，也不需要考虑人家是否调用成功、失败超时等情况。"),t("br"),a._v(" "),t("strong",[a._v("异步")]),a._v("：A 系统接收一个请求，需要在自己本地写库，还需要在 BCD 三个系统写库，自己本地写库要 3ms，BCD 三个系统分别写库要 300ms、450ms、200ms。最终请求总延时是 3 + 300 + 450 + 200 = 953ms，接近 1s，用户感觉搞个什么东西，慢死了慢死了。用户通过浏览器发起请求。如果使用 MQ，那么 A 系统连续发送 3 条消息到 MQ 队列中，假如耗时 5ms，A 系统从接受一个请求到返回响应给用户，总时长是 3 + 5 = 8ms。"),t("br"),a._v(" "),t("strong",[a._v("削峰")]),a._v("：减少高峰时期对服务器压力。")]),a._v(" "),t("h2",{attrs:{id:"消息队列有什么缺点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#消息队列有什么缺点"}},[a._v("#")]),a._v(" 消息队列有什么缺点")]),a._v(" "),t("p",[t("strong",[a._v("系统可用性降低")]),a._v("\n本来系统运行好好的，现在你非要加入个消息队列进去，那消息队列挂了，你的系统不是呵呵了。因此，系统可用性会降低；"),t("br"),a._v(" "),t("strong",[a._v("系统复杂度提高")]),a._v("\n加入了消息队列，要多考虑很多方面的问题，比如：一致性问题、如何保证消息不被重复消费、如何保证消息可靠性传输等。因此，需要考虑的东西更多，复杂性增大。"),t("br"),a._v(" "),t("strong",[a._v("一致性问题")]),a._v("\nA 系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是 BCD 三个系统那里，BD 两个系统写库成功了，结果 C 系统写库失败了，咋整？你这数据就不一致了。")]),a._v(" "),t("h2",{attrs:{id:"rabbitmq的核心概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rabbitmq的核心概念"}},[a._v("#")]),a._v(" RabbitMQ的核心概念")]),a._v(" "),t("p",[a._v("RabbitMQ 的核心概念主要涵盖以下几个方面：")]),a._v(" "),t("ol",[t("li",[a._v("消息（Message）："),t("br"),a._v("\n消息是 RabbitMQ 中的基本数据单元，用于在应用程序之间传递信息。它由消息头和消息体组成，消息头包含一些元数据，例如路由键等。消息体则包含实际的数据。")]),a._v(" "),t("li",[a._v("生产者（Producer）："),t("br"),a._v("\n生产者是消息的发送者，负责将消息发布到 RabbitMQ 中。它将消息发送到交换机，并指定一个路由键，以描述消息的目标。")]),a._v(" "),t("li",[a._v("交换机（Exchange）："),t("br"),a._v("\n交换机是消息的路由中心，接收来自生产者的消息，并根据特定规则将其路由到一个或多个队列。它根据路由键和绑定规则决定将消息发送到哪些队列。")]),a._v(" "),t("li",[a._v("队列（Queue）："),t("br"),a._v("\n队列是 RabbitMQ 中的消息存储区域，用于暂时保存待处理的消息。生产者将消息发送到交换机，交换机将消息路由到一个或多个队列，消费者则从队列中获取消息进行处理。")]),a._v(" "),t("li",[a._v("消费者（Consumer）："),t("br"),a._v("\n消费者是消息的接收者，负责从队列中获取消息并进行处理。消费者连接到 RabbitMQ，并订阅一个或多个队列以接收发布者发送的消息。一旦有消息可用，消费者将获取并处理该消息。")]),a._v(" "),t("li",[a._v("绑定（Binding）："),t("br"),a._v("\n绑定是交换机和队列之间的关联关系。它定义了交换机如何将消息路由到特定的队列。绑定通常包含一个绑定键（binding key），用于与消息的路由键进行匹配。")]),a._v(" "),t("li",[a._v("路由键（Routing Key）："),t("br"),a._v("\n路由键是用于消息路由的关键字，生产者在发送消息时将消息的路由键与交换机的绑定键进行匹配。交换机根据路由键的匹配结果将消息发送到相应的队列。")]),a._v(" "),t("li",[a._v("声明（Declaration）："),t("br"),a._v("\n在 RabbitMQ 中，声明是指创建交换机、队列和绑定的过程。在使用这些组件之前，需要先声明它们，以确保它们的存在和正确配置。"),t("br"),a._v("\n这些核心概念构成了 RabbitMQ 的基础架构和消息传递流程。了解这些概念可以帮助我们理解 RabbitMQ 的工作原理，并能够设计和实现可靠的消息传递系统。")])]),a._v(" "),t("h2",{attrs:{id:"rabbitmq的工作模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rabbitmq的工作模式"}},[a._v("#")]),a._v(" RabbitMQ的工作模式")]),a._v(" "),t("ol",[t("li",[a._v("简单模式（Simple Mode）："),t("br"),a._v("\n在简单模式中，一个生产者将消息发送到一个队列，然后一个消费者从该队列接收和处理消息。这是 RabbitMQ 中最基本的工作模式，适用于单个生产者和单个消费者的场景。")]),a._v(" "),t("li",[a._v("工作队列模式（Work Queue Mode）："),t("br"),a._v("\n工作队列模式中，一个生产者将消息发送到一个队列，多个消费者同时监听该队列，并竞争获取消息进行处理。消息在多个消费者之间被分发，每个消息只被一个消费者处理。这种模式适用于需要在多个消费者之间进行负载均衡的场景。")]),a._v(" "),t("li",[a._v("发布/订阅模式（Publish/Subscribe Mode）："),t("br"),a._v("\n发布/订阅模式中，一个生产者将消息发送到一个交换机，该交换机将消息广播到多个队列。每个队列都有一个消费者监听并接收消息。这种模式适用于需要将消息广播给多个消费者的场景。")]),a._v(" "),t("li",[a._v("路由模式（Routing Mode）："),t("br"),a._v("\n路由模式中，一个生产者将消息发送到一个交换机，并使用特定的路由键来描述消息的目标。交换机根据路由键将消息路由到特定的队列，每个队列都有一个消费者监听并接收消息。这种模式适用于根据路由键将消息分发到不同队列的场景。")]),a._v(" "),t("li",[a._v("主题模式（Topic Mode）："),t("br"),a._v("\n主题模式中，一个生产者将消息发送到一个交换机，并使用主题（通配符）来描述消息的特征。交换机根据主题匹配规则将消息路由到符合条件的队列，每个队列都有一个消费者监听并接收消息。这种模式适用于需要根据消息的特征进行灵活路由的场景。")])]),a._v(" "),t("h2",{attrs:{id:"如何保证rabbitmq消息的顺序性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何保证rabbitmq消息的顺序性"}},[a._v("#")]),a._v(" 如何保证RabbitMQ消息的顺序性？")]),a._v(" "),t("p",[a._v("1.拆分多个 queue(消息队列)，每个 queue(消息队列) 一个 consumer(消费者)，就是多一些 queue (消息队列)而已，确实是麻烦点；"),t("br"),a._v("\n2.或者就一个 queue (消息队列)但是对应一个 consumer(消费者)，然后这个 consumer(消费者)内部用内存队列做排队，然后分发给底层不同的 worker 来处理。")]),a._v(" "),t("h2",{attrs:{id:"如何保证rabbitmq消息的可靠传输"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何保证rabbitmq消息的可靠传输"}},[a._v("#")]),a._v(" 如何保证RabbitMQ消息的可靠传输？")]),a._v(" "),t("p",[a._v("生产者到 RabbitMQ：事务机制和 Confirm 机制，注意：事务机制和 Confirm 机制是互斥的，两者不能共存，会导致 RabbitMQ 报错。"),t("br"),a._v("\nRabbitMQ 自身：持久化、集群、普通模式、镜像模式。"),t("br"),a._v("\nRabbitMQ 到消费者：basicAck 机制、死信队列、消息补偿机制")]),a._v(" "),t("h2",{attrs:{id:"什么是死信队列"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是死信队列"}},[a._v("#")]),a._v(" 什么是死信队列")]),a._v(" "),t("p",[a._v("死信队列（Dead Letter Queue，简称DLQ）是消息中间件中的一个概念，包括在 RabbitMQ 中。它用于处理无法被消费者成功处理的消息，通常是因为消息过期、消费者无法处理或达到最大重试次数等情况。"),t("br"),a._v("\n当消息被标记为死信时，它将被重新路由到一个特殊的队列，即死信队列。这个队列可以被单独的消费者或者专门的处理逻辑来消费和处理。死信队列允许对无法正常处理的消息进行后续处理，以便进行错误处理、重试或记录日志等操作。"),t("br"),a._v(" "),t("strong",[a._v("死信队列的使用场景包括")]),a._v("：\n  1. 消息过期：当消息在一定时间内未被消费者处理，可以被标记为死信并转发到死信队列，避免消息一直阻塞在队列中。\n  2. 消费失败：当消费者在处理消息时发生错误或无法处理时，可以将消息标记为死信，并将其发送到死信队列，以便进一步进行错误处理或重试。\n  3. 消息重试：当消息消费失败时，可以将消息发送到死信队列，并在死信队列中进行一系列的重试策略，以尝试重新处理这些失败的消息。\n通过使用死信队列，我们可以更好地处理无法被消费者成功处理的消息，实现错误恢复和消息重试的机制。这提高了消息系统的可靠性和容错性，并确保重要的消息不会被丢失或永远阻塞在队列中。")]),a._v(" "),t("h2",{attrs:{id:"kafka和rabbitmq的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#kafka和rabbitmq的区别"}},[a._v("#")]),a._v(" kafka和RabbitMQ的区别")]),a._v(" "),t("p",[a._v("RabbitMQ和Kafka是两个不同的消息中间件，它们在设计和使用上有一些区别。以下是RabbitMQ和Kafka之间的一些主要区别：")]),a._v(" "),t("ol",[t("li",[a._v("数据处理模型：\n"),t("ul",[t("li",[a._v("RabbitMQ：RabbitMQ是基于传统的消息队列模型，使用队列来存储消息，并按照先进先出（FIFO）的顺序进行消息传递。它支持多种消息模式，如点对点（Point-to-Point）和发布/订阅（Publish/Subscribe）模式。")]),a._v(" "),t("li",[a._v("Kafka：Kafka是一种分布式的流处理平台，它采用了发布/订阅模型。数据以topic（主题）的形式进行发布，并且可以被多个消费者组（Consumer Group）并行地消费。Kafka以日志的形式存储消息，可以保留一定时间的历史数据。")])])]),a._v(" "),t("li",[a._v("数据存储和持久化：\n"),t("ul",[t("li",[a._v("RabbitMQ：RabbitMQ使用队列进行消息存储，可以将消息持久化到磁盘上，以确保消息在服务重启后不会丢失。它适合于实时性要求较高、消息量较小的场景。")]),a._v(" "),t("li",[a._v("Kafka：Kafka使用日志存储消息，保留了一段时间内的历史消息。它的存储机制基于文件系统，可以处理高吞吐量的数据流。Kafka适用于需要持久化大量数据和支持数据回放的场景。")])])]),a._v(" "),t("li",[a._v("数据处理能力和延迟：\n"),t("ul",[t("li",[a._v("RabbitMQ：RabbitMQ适用于低延迟的消息传递，具有快速的消息投递和消费响应时间。它适合于需要即时性和可靠性的应用场景。")]),a._v(" "),t("li",[a._v("Kafka：Kafka在处理大规模数据流时表现出色，具有高吞吐量和低延迟的特点。它适用于需要处理大量数据和实时数据流的场景。")])])]),a._v(" "),t("li",[a._v("生态系统和使用场景：\n"),t("ul",[t("li",[a._v("RabbitMQ：RabbitMQ是一个成熟的消息中间件，有广泛的使用和支持。它适用于各种传统的应用场景，如任务队列、发布/订阅、异步通信等。")]),a._v(" "),t("li",[a._v("Kafka：Kafka是为大数据流和流处理场景设计的，具有强大的数据处理能力。它适用于日志收集、实时数据处理、事件驱动架构等场景。")])])])])])}),[],!1,null,null,null);t.default=r.exports}}]);