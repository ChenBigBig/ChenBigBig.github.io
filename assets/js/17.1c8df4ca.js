(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{287:function(v,_,r){"use strict";r.r(_);var t=r(14),a=Object(t.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"关系型数据库【mysql】"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#关系型数据库【mysql】"}},[v._v("#")]),v._v(" 关系型数据库【MySQL】")]),v._v(" "),_("h2",{attrs:{id:"什么是mysql"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是mysql"}},[v._v("#")]),v._v(" 什么是Mysql")]),v._v(" "),_("p",[v._v("MySQL是一个关系型数据库，它采用表的形式来存储数据。你可以理解成是Excel表格，既然是表的形式存储数据，就有表结构（行和列）。行代表每一行数据，列代表该行中的每个值。列上的值是有数据类型的，比如：整数、字符串、日期等等。")]),v._v(" "),_("h2",{attrs:{id:"数据库三范式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数据库三范式"}},[v._v("#")]),v._v(" 数据库三范式")]),v._v(" "),_("p",[v._v("第一范式：属性不可再分。"),_("br"),v._v("\n第二范式：首先需满足第一范式，另外包含两部分内容，第一是表必须有一个主键，第二是非主键列必须完全依赖于主键，而不能只依赖于主键的一部分。"),_("br"),v._v("\n第三范式：首先需满足第二范式，另外非主键必须直接依赖于主键，不能存在传递依赖。")]),v._v(" "),_("h2",{attrs:{id:"drop、delete、truncate区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#drop、delete、truncate区别"}},[v._v("#")]),v._v(" drop、delete、truncate区别")]),v._v(" "),_("p",[v._v("SQL中的drop、delete、truncate都表示删除，但是三者有一些差别"),_("br"),v._v("\n1.drop:丢弃数据 -> drop table 表名 直接将表都删除掉，在删除表的时候使用。"),_("br"),v._v("\n2.delete:清空数据 -> delete from 表名 where 列名=值 删除某一行的数据，如果不加 where 子句和truncate table 表名作用类似。"),_("br"),v._v("\n3.truncate:删除数据 -> truncate table 表名 只删除表中的数据，再插入数据的时候自增长 id 又从 1 开始，在清空表中数据的时候使用。"),_("br"),v._v("\ntruncate 和 delete 只删除数据不删除表的结构；drop 语句将删除表的结构被依赖的约束、触发器、索引"),_("br"),v._v("\n一般来说，执行速度: drop > truncate > delete")]),v._v(" "),_("h2",{attrs:{id:"什么是存储过程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是存储过程"}},[v._v("#")]),v._v(" 什么是存储过程")]),v._v(" "),_("p",[v._v("我们可以把存储过程看成是一些 SQL 语句的集合，中间加了点逻辑控制语句。存储过程在业务比较复杂的时候是非常实用的，比如很多时候我们完成一个操作可能需要写一大串 SQL 语句，这时候我们就可以写有一个存储过程，这样也方便了我们下一次的调用。存储过程一旦调试完成通过后就能稳定运行，另外，使用存储过程比单纯 SQL 语句执行要快，因为存储过程是预编译过的。"),_("br"),v._v("\n存储过程的优点："),_("br"),v._v("\n1）存储过程是预编译过的，执行效率高。"),_("br"),v._v("\n2）存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。"),_("br"),v._v("\n3）安全性高，执行存储过程需要有一定权限的用户。"),_("br"),v._v("\n4）存储过程可以重复使用，可减少数据库开发人员的工作量。")]),v._v(" "),_("h2",{attrs:{id:"存储过程和函数的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#存储过程和函数的区别"}},[v._v("#")]),v._v(" 存储过程和函数的区别")]),v._v(" "),_("p",[_("img",{attrs:{src:"/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB.png",alt:"存储过程和函数的区别"}})]),v._v(" "),_("h2",{attrs:{id:"什么是触发器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是触发器"}},[v._v("#")]),v._v(" 什么是触发器")]),v._v(" "),_("p",[v._v("触发器是一种特殊的存储过程，主要是通过事件来触发而被执行的。它可以强化约束，来维护数据的完整性和一致性，可以跟踪数据库内的操作从而不允许未经许可的更新和变化。可以联级运算。如，某表上的触发器上包含对另一个表的数据操作，而该操作又会导致该表触发器被触发。")]),v._v(" "),_("h2",{attrs:{id:"常见的存储引擎有哪些"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#常见的存储引擎有哪些"}},[v._v("#")]),v._v(" 常见的存储引擎有哪些")]),v._v(" "),_("p",[v._v("MySQL常见的三种存储引擎（InnoDB、MyISAM、MEMORY）"),_("br"),v._v("\n1.InnoDB支持事务，MyISAM不支持， 这一点是非常之重要。事务是一种高级的处理方式，如在一些列增删改中只要哪个出错还可以回滚还原，而MyISAM就不可以了。"),_("br"),v._v("\n2.MyISAM适合查询以及插入为主的应用。"),_("br"),v._v("\n3.InnoDB适合频繁修改以及涉及到安全性较高的应用。"),_("br"),v._v("\n4.InnoDB支持外键，MyISAM不支持。"),_("br"),v._v("\n5.从MySQL5.5.5以后，InnoDB是默认引擎。"),_("br"),v._v(" "),_("strong",[v._v("INNODB会支持一些关系数据库的高级功能，如事务功能和行级锁，MyISAM不支持。")]),v._v(" "),_("strong",[v._v("2.MyISAM的性能更优，占用的存储空间少，所以，选择何种存储引擎，视具体应用而定。")])]),v._v(" "),_("h2",{attrs:{id:"数据库的索引"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数据库的索引"}},[v._v("#")]),v._v(" 数据库的索引")]),v._v(" "),_("p",[v._v("索引是存储引擎用于提高数据库表的访问速度的一种数据结构。它可以比作一本字典的目录，可以帮你快速找到对应的记录。索引一般存储在磁盘的文件中，它是占用物理空间的。"),_("br"),v._v("\n优点："),_("br"),v._v("\n1.加快数据查找的速度"),_("br"),v._v("\n2.为用来排序或者是分组的字段添加索引，可以加快分组和排序的速度"),_("br"),v._v("\n3.加快表与表之间的连接"),_("br"),v._v("\n缺点："),_("br"),v._v("\n1.建立索引需要占用物理空间"),_("br"),v._v("\n2.会降低表的增删改的效率，因为每次对表记录进行增删改，需要进行动态维护索引，导致增删改时间变长")]),v._v(" "),_("h2",{attrs:{id:"什么情况下需要创建索引-什么情况下不建索引"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么情况下需要创建索引-什么情况下不建索引"}},[v._v("#")]),v._v(" 什么情况下需要创建索引？什么情况下不建索引？")]),v._v(" "),_("p",[v._v("1.什么情况下需要创建索引：")]),v._v(" "),_("ul",[_("li",[v._v("经常用于查询的字段")]),v._v(" "),_("li",[v._v("经常用于连接的字段建立索引，可以加快连接的速度")]),v._v(" "),_("li",[v._v("经常需要排序的字段建立索引，因为索引已经排好序，可以加快排序查询速度")])]),v._v(" "),_("p",[v._v("2.什么情况下不建索引:")]),v._v(" "),_("ul",[_("li",[v._v("where条件中用不到的字段不适合建立索引表记录较少。")]),v._v(" "),_("li",[v._v("比如只有几百条数据，没必要加索引。")]),v._v(" "),_("li",[v._v("需要经常增删改。需要评估是否适合加索引")]),v._v(" "),_("li",[v._v("参与列计算的列不适合建索引区分度不高的字段不适合建立索引，如性别，只有男/女/未知三个值。加了索引，查询效率也不会提高。")])]),v._v(" "),_("h2",{attrs:{id:"mysql的事务-事务的四大特性-事务的隔离级别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#mysql的事务-事务的四大特性-事务的隔离级别"}},[v._v("#")]),v._v(" mysql的事务（事务的四大特性，事务的隔离级别）")]),v._v(" "),_("p",[v._v("什么是事务：事务是指单个逻辑工作单元执行得一系列操作，要么都做，要么都不做，是不可分割的工作单位，是数据库环境中的的最小工作单元。"),_("br"),v._v("\n事务的四大特性："),_("strong",[v._v("(ACID)")]),_("br"),v._v(" "),_("strong",[v._v("原子性")]),v._v("：事务包含的所有操作要么全部成功，要么全部失败回滚。"),_("br"),v._v(" "),_("strong",[v._v("一致性")]),v._v("：是指一个事务执行之前和执行之后都必须处于一致性状态。比如a与b账户共有1000块，两人之间转账之后无论成功还是失败，它们的账户总和还是1000。"),_("br"),v._v(" "),_("strong",[v._v("隔离性")]),v._v("：跟隔离级别相关，一个事务只能读到已经提交的修改。"),_("br"),v._v(" "),_("strong",[v._v("持久性")]),v._v("：一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。")]),v._v(" "),_("p",[v._v("从理论上来说, 事务应该彼此完全隔离, 以避免并发事务所导致的问题，然而, 那样会对性能产生极大的影响, 因为事务必须按顺序运行， 在实际开发中, 为了提升性能, 事务会以较低的隔离级别运行， 事务的隔离级别可以通过隔离事务属性指定。")]),v._v(" "),_("p",[v._v("事务的隔离级别：（读未提交、不可重复读、读已提交、串行化）"),_("br"),v._v(" "),_("strong",[v._v("脏读")]),v._v("：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据"),_("br"),v._v(" "),_("strong",[v._v("不可重复读")]),v._v("：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果因此本事务先后两次读到的数据结果会不一致。"),_("br"),v._v(" "),_("strong",[v._v("幻读")]),v._v("：是当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录。")]),v._v(" "),_("p",[_("strong",[v._v("读未提交")]),v._v("：另一个事务修改了数据，但尚未提交，而本事务中的SELECT会读到这些未被提交的数据脏读"),_("br"),v._v(" "),_("strong",[v._v("读已提交")]),v._v("：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果因此本事务先后两次读到的数据结果会不一致。"),_("br"),v._v(" "),_("strong",[v._v("可重复读")]),v._v("：在同一个事务里，SELECT的结果是事务开始时时间点的状态，因此，同样的SELECT操作读到的结果会是一致的。但是，会有幻读现象"),_("br"),v._v(" "),_("strong",[v._v("串行化")]),v._v("：最高的隔离级别，在这个隔离级别下，不会产生任何异常。并发的事务，就像事务是在一个个按照顺序执行一样")]),v._v(" "),_("h2",{attrs:{id:"mysql查询语句中的优化方式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#mysql查询语句中的优化方式"}},[v._v("#")]),v._v(" MySQL查询语句中的优化方式")]),v._v(" "),_("ol",[_("li",[v._v("使用 EXPLAIN 分析查询性能：使用 EXPLAIN 可以分析查询性能，查看查询语句中的执行计划，找出慢查询的原因。")]),v._v(" "),_("li",[v._v("减少 SELECT 的列数：只选择需要查询的列，避免使用 SELECT *，可以减少查询的数据量，提高查询效率。")]),v._v(" "),_("li",[v._v("使用索引：对查询经常使用的列添加索引，可以减少查询时需要扫描的行数，提高查询效率。")]),v._v(" "),_("li",[v._v("避免在 WHERE 子句中使用函数或计算符号：在 WHERE 子句中使用函数或计算符号，会导致 MySQL 无法使用索引，影响查询性能。\n-应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描。\n-应尽量避免在 where 子句中使用 != 或 <> 操作符，否则将引擎放弃使用索引而进行全表扫描。\n-应尽量避免在 where 子句中使用 or 来连接条件，如果一个字段有索引，一个字段没有索引，将导致引擎放弃使用索引而进行全表扫描。\n-in 和 not in 也要慎用，否则会导致全表扫描")]),v._v(" "),_("li",[v._v("使用 UNION ALL 代替 UNION：UNION 会将结果中重复的行去重，而 UNION ALL 不会，因此在确定结果不会有重复行的情况下，使用 UNION ALL 可以提高查询效率。")]),v._v(" "),_("li",[v._v("尽量使用 INNER JOIN 替换 WHERE 子句：使用 INNER JOIN 能够让 MySQL 优先执行 JOIN 操作，而不是先过滤数据，避免一次性读取大量无用数据。")]),v._v(" "),_("li",[v._v("避免使用子查询：子查询会使 MySQL 重新执行一次查询，极大地影响查询性能，尽可能避免使用子查询。")]),v._v(" "),_("li",[v._v("控制查询返回的数据量：数据量过大会导致查询过慢，应该限制查询结果返回的数据量，使用 LIMIT 可以限制查询返回的数据行数。")])]),v._v(" "),_("h2",{attrs:{id:"mysql查询常见的优化方式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#mysql查询常见的优化方式"}},[v._v("#")]),v._v(" MySQL查询常见的优化方式")]),v._v(" "),_("ol",[_("li",[v._v("索引优化：为查询中经常使用的列创建索引，可以提高查询速度。需要注意的是，不是所有的查询列都需要创建索引，创建过多的索引会降低写入性能，还会增加索引维护的开销。")]),v._v(" "),_("li",[v._v("SQL 优化：优化 SQL 查询语句可以增加查询速度。例如，应尽量避免使用 SELECT *，尽量精确指定所需列，避免使用子查询，避免使用多个 UNION、DISTINCT 和 GROUP BY，等等。")]),v._v(" "),_("li",[v._v("垂直拆分表：将一张大表按照数据相关性将其字段拆分成多个表，可以减小单个查询需要扫描的行数，提高查询效率。")]),v._v(" "),_("li",[v._v("水平分割表：将大表拆成多个小表，按不同的维度拆分，如按时间、地域、状态等，可以减少单个查询需要扫描的行数，提高查询效率。")]),v._v(" "),_("li",[v._v("分区表：将大表划分成多个分区，可以减少单个查询需要扫描的行数，并且在查询时只需要查询相关的分区，提高查询效率。")]),v._v(" "),_("li",[v._v("缓存查询结果：对于一些常用的查询语句，将其结果进行缓存，可以避免重复查询数据库，提高查询效率。")]),v._v(" "),_("li",[v._v("调整服务器参数：适当地调整 MySQL 的服务器参数，可根据服务器硬件配置、应用场景选择最优参数，可以进一步提高查询效率。")])]),v._v(" "),_("h2",{attrs:{id:"什么是视图-什么是游标"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是视图-什么是游标"}},[v._v("#")]),v._v(" 什么是视图，什么是游标")]),v._v(" "),_("ul",[_("li",[v._v("视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。")]),v._v(" "),_("li",[v._v("游标是对查询出来的结果集作为一个单元来有效的处理。游标可以定在该单元中的特定行，从结果集的当前行检索一行或多行。可以对结果集当前行做修改。一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。")])]),v._v(" "),_("h2",{attrs:{id:"视图的优点和缺点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#视图的优点和缺点"}},[v._v("#")]),v._v(" 视图的优点和缺点")]),v._v(" "),_("p",[v._v("优点："),_("br"),v._v("\n1)对数据库的访问，因为视图可以有选择性的选取数据库里的一部分。"),_("br"),v._v("\n2)用户通过简单的查询可以从复杂查询中得到结果。"),_("br"),v._v("\n3)维护数据的独立性，试图可从多个表检索数据。"),_("br"),v._v("\n4)对于相同的数据可产生不同的视图。"),_("br"),v._v("\n缺点："),_("br"),v._v("\n性能：查询视图时，必须把视图的查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么，那么就无法更改数据")]),v._v(" "),_("h2",{attrs:{id:"mysql和oracle和sql-server的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#mysql和oracle和sql-server的区别"}},[v._v("#")]),v._v(" Mysql和Oracle和SQL Server的区别")]),v._v(" "),_("p",[v._v("MySQL、Oracle和SQL Server都是关系型数据库管理系统（RDBMS），主要用于存储和管理大规模的数据。"),_("br"),v._v("\nMySQL是一种开放源代码的关系型数据库管理系统，隶属于Oracle公司。"),_("br"),v._v("\nOracle是一种商业关系型数据库管理系统，隶属于Oracle公司。"),_("br"),v._v("\nSQL Server是一种商业关系型数据库管理系统，隶属于Microsoft公司"),_("br"),v._v("\nOracle和SQL Server具有更多的功能和特性，如支持分布式数据库、高可用性、自动备份和恢复等。MySQL的功能和特性相对较少。")]),v._v(" "),_("h2",{attrs:{id:"列举几种表连接的方式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#列举几种表连接的方式"}},[v._v("#")]),v._v(" 列举几种表连接的方式")]),v._v(" "),_("p",[v._v("等值连接（内连接）、非等连接、自连接、外连接（左、右、全）"),_("br"),v._v("\n内连接又称等值连接，筛选完全匹配的行"),_("br"),v._v("\n左连接以左表为主，筛选完全匹配的行之外还会把左表中没有匹配的行也筛选，找不到匹配的数据用null填充"),_("br"),v._v("\n右连接以右表为主，筛选完全匹配的行之外还会把有表中没有匹配的行也帅选，找不到匹配的数据用null填充")]),v._v(" "),_("h2",{attrs:{id:"char和varchar的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#char和varchar的区别"}},[v._v("#")]),v._v(" char和varchar的区别")]),v._v(" "),_("p",[v._v("CHAR的长度是不可变的，而VARCHAR的长度是可变的"),_("br"),v._v("\nCHAR的存取速度要比VARCHAR快得很多")]),v._v(" "),_("h2",{attrs:{id:"like中通配符-和-的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#like中通配符-和-的区别"}},[v._v("#")]),v._v(" like中通配符%和—的区别")]),v._v(" "),_("p",[v._v("%百分号通配符：表示任何字符串出现任意次数（可以是0次）"),_("br"),v._v("\n—下划线通配符：表示只能匹配单个字符，不能多也不能少，就是一个字符")]),v._v(" "),_("h2",{attrs:{id:"索引底层的数据结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#索引底层的数据结构"}},[v._v("#")]),v._v(" 索引底层的数据结构")]),v._v(" "),_("p",[v._v("索引底层的数据结构通常有B树和哈希表两种，其中B树是最常用的索引数据结构，MySQL中的InnoDB存储引擎就采用了B+树作为索引的底层数据结构。"),_("br"),v._v("\nHash索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位;"),_("br"),v._v("\nB+树索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问;")]),v._v(" "),_("h2",{attrs:{id:"索引什么时候会失效"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#索引什么时候会失效"}},[v._v("#")]),v._v(" 索引什么时候会失效")]),v._v(" "),_("p",[v._v("数据库索引失效是指在查询数据时，无法使用现有的索引而需要进行全表扫描，导致查询效率低下的情况。以下是一些可能导致索引失效的场景：")]),v._v(" "),_("ol",[_("li",[v._v("对索引列进行了函数操作，如SELECT * FROM table WHERE YEAR(date_column) = 2021；")]),v._v(" "),_("li",[v._v("对索引列进行了类型转换，如SELECT * FROM table WHERE integer_column = '1'；")]),v._v(" "),_("li",[v._v("重复值多的列上建立索引，如性别列，此时索引失效会比较容易发生；")]),v._v(" "),_("li",[v._v("使用了模糊查询LIKE '%xxx%'，此时索引失效也比较容易发生；")]),v._v(" "),_("li",[v._v("数据库表中的数据量过大，导致索引在查询时无效；")]),v._v(" "),_("li",[v._v("子查询中的语句无法使用索引，如SELECT * FROM table WHERE column_name IN (SELECT column_name FROM table2)；")]),v._v(" "),_("li",[v._v("对多个列建立的联合索引，查询不包含前面的列，后续的列索引失效；")]),v._v(" "),_("li",[v._v("使用了MySQL的优化器规则，导致索引失效，比如使用了强制类型转换或LIKE表达式。")])])])}),[],!1,null,null,null);_.default=a.exports}}]);