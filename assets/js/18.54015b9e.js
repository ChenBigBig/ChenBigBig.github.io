(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{290:function(s,r,e){"use strict";e.r(r);var i=e(14),t=Object(i.a)({},(function(){var s=this,r=s._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[r("h1",{attrs:{id:"非关系型数据库【redis】"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#非关系型数据库【redis】"}},[s._v("#")]),s._v(" 非关系型数据库【Redis】")]),s._v(" "),r("h2",{attrs:{id:"什么是redis"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#什么是redis"}},[s._v("#")]),s._v(" 什么是Redis")]),s._v(" "),r("p",[s._v("Redis 是一个使用 C 语言写成的，开源的高性能key-value非关系缓存数据库。它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set --有序集合)和hash（哈希类型）。Redis的数据都基于缓存的，所以很快，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。Redis也可以实现数据写入磁盘中，保证了数据的安全不丢失，而且Redis的操作是原子性的。")]),s._v(" "),r("h2",{attrs:{id:"redis有哪些有点和缺点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#redis有哪些有点和缺点"}},[s._v("#")]),s._v(" Redis有哪些有点和缺点")]),s._v(" "),r("p",[s._v("优点："),r("br"),s._v("\n  1.读写性能优异（基于内存）， Redis能读的速度是110000次/s，写的速度是81000次/s。"),r("br"),s._v("\n  2.支持数据持久化，支持AOF和RDB两种持久化方式。"),r("br"),s._v("\n  3.支持事务，Redis的所有操作都是原子性的，同时Redis还支持对几个操作合并后的原子性执行。"),r("br"),s._v("\n  4.数据结构丰富，除了支持string类型的value外还支持hash、set、zset、list等数据结构。"),r("br"),s._v("\n  5.支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。"),r("br"),s._v("\n缺点："),r("br"),s._v("\n  1.数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。"),r("br"),s._v("\n  2.Redis 不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的IP才能恢复。"),r("br"),s._v("\n  3.主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性。"),r("br"),s._v("\n  4.Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。")]),s._v(" "),r("h2",{attrs:{id:"为什么要使用redis-为什么要用缓存"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#为什么要使用redis-为什么要用缓存"}},[s._v("#")]),s._v(" 为什么要使用Redis/为什么要用缓存")]),s._v(" "),r("p",[s._v("1:高性能："),r("br"),s._v("\n  假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在数缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！"),r("br"),s._v("\n2:高并发："),r("br"),s._v("\n  直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。")]),s._v(" "),r("h2",{attrs:{id:"redis为什么这么快"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#redis为什么这么快"}},[s._v("#")]),s._v(" Redis为什么这么快")]),s._v(" "),r("p",[s._v("1、完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是O(1)；"),r("br"),s._v("\n2、数据结构简单，对数据操作也简单，Redis 中的数据结构是专门进行设计的；"),r("br"),s._v("\n3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；"),r("br"),s._v("\n4、使用多路 I/O 复用模型，非阻塞 IO；"),r("br"),s._v("\n5、使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis 直接自己构建了 VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；")]),s._v(" "),r("h2",{attrs:{id:"redis有哪些数据类型"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#redis有哪些数据类型"}},[s._v("#")]),s._v(" Redis有哪些数据类型")]),s._v(" "),r("p",[s._v("Redis主要有5种数据类型，包括String，List，Set，Zset，Hash，满足大部分的使用要求")]),s._v(" "),r("h2",{attrs:{id:"redis的持久化-redis持久化的机制有哪些-各自的优缺点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#redis的持久化-redis持久化的机制有哪些-各自的优缺点"}},[s._v("#")]),s._v(" Redis的持久化？Redis持久化的机制有哪些？各自的优缺点？")]),s._v(" "),r("p",[s._v("Redis 提供两种持久化机制 RDB（默认）和 AOF 机制:"),r("br"),s._v("\nRDB:Redis DataBase缩写快照"),r("br"),s._v("\n  RDB是Redis默认的持久化方式。按照一定的时间将内存的数据以快照的形式保存到硬盘中，对应产生的数据文件为dump.rdb。通过配置文件中的save参数来定义快照的周期。"),r("br"),s._v("\n  AOF持久化(即Append Only File持久化)，则是将Redis执行的每次写命令记录到单独的日志文件中，当重启Redis会重新将持久化的日志中文件恢复数据。"),r("br"),s._v("\n当两种方式同时开启时，数据恢复Redis会优先选择AOF恢复")]),s._v(" "),r("h2",{attrs:{id:"什么是redis穿透-什么是redis雪崩"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#什么是redis穿透-什么是redis雪崩"}},[s._v("#")]),s._v(" 什么是Redis穿透，什么是Redis雪崩")]),s._v(" "),r("p",[s._v("Redis穿透:"),r("br"),s._v("\nRedis穿透指的是当一个查询请求在缓存中找不到对应的数据时，也无法从后端数据库中获取到数据，导致每次请求都会穿透缓存直接访问数据库。这可能是由于恶意攻击、错误的缓存配置或者数据丢失等原因导致的。"),r("br"),s._v("\n解决方案:"),r("br"),s._v("\n  1.使用布隆过滤器（Bloom Filter）等技术，在缓存层面进行数据的预判，从而避免无效请求直接访问数据库。"),r("br"),s._v("\n  2.对于查询为空的结果，也将其缓存，但设置一个较短的过期时间，以避免攻击者频繁发起同样的请求。"),r("br"),s._v("\nRedis雪崩:"),r("br"),s._v("\nRedis雪崩指的是在某个时间点，缓存中大量的数据同时失效或过期，导致大量的请求直接访问后端数据库，从而造成数据库压力过大，性能下降甚至崩溃的情况。"),r("br"),s._v("\n解决方案:"),r("br"),s._v("\n  1.为缓存的数据设置合适的过期时间，并采用不同的过期时间进行分散，避免集中失效。"),r("br"),s._v("\n  2.在高峰期对缓存进行预热，提前主动加载数据到缓存中，减少缓存同时失效的概率。"),r("br"),s._v("\n  3.使用多级缓存架构，引入多个缓存层，如本地缓存和分布式缓存，以提高系统的容错性和可用性。")]),s._v(" "),r("h2",{attrs:{id:"什么是redis缓存预热"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#什么是redis缓存预热"}},[s._v("#")]),s._v(" 什么是Redis缓存预热")]),s._v(" "),r("p",[s._v("缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！")])])}),[],!1,null,null,null);r.default=t.exports}}]);