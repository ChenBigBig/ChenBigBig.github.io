(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{285:function(a,r,t){"use strict";t.r(r);var v=t(14),s=Object(v.a)({},(function(){var a=this,r=a._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("h1",{attrs:{id:"java基础篇"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#java基础篇"}},[a._v("#")]),a._v(" Java基础篇")]),a._v(" "),r("h2",{attrs:{id:"java语言特点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#java语言特点"}},[a._v("#")]),a._v(" Java语言特点")]),a._v(" "),r("p",[a._v("Java语言简单性，学起来更加简单，使用起来更加的方便，她是一种面向对象的编程语言。具有高性能，安全性，健壮性特点。"),r("br"),a._v("\nJava 是一种可以撰写跨平台应用程序的面向对象的程序设计语言。")]),a._v(" "),r("h2",{attrs:{id:"java跨平台原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#java跨平台原理"}},[a._v("#")]),a._v(" Java跨平台原理：")]),a._v(" "),r("p",[a._v("Java 源程序（.java文件）通过编译器编译成为 Class 文件（字节码文件），而它的 class 文件是基于字节码（以 byte为单位存储的文件）的，而字节码文件是描述程序要运行的的虚指令的集合，这些虚指令的集合与任何的平台无关，Java 虚拟机认识它（只要在不同的平台下部署相应的 JRE，运行 JVM就可以了）")]),a._v(" "),r("h2",{attrs:{id:"jvm-jre-jdk"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#jvm-jre-jdk"}},[a._v("#")]),a._v(" JVM/JRE/JDK")]),a._v(" "),r("p",[a._v("JVM：java虚拟机，运行Java字节码的虚拟机，JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。"),r("br"),a._v("\nJRE：JRE 是 Java 运行时环境，仅包含 Java 应用程序的运行时环境和必要的类库"),r("br"),a._v("\nJDK：是提供给开发者使用的，能够创建或编译java程序。")]),a._v(" "),r("h2",{attrs:{id:"java注释"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#java注释"}},[a._v("#")]),a._v(" Java注释")]),a._v(" "),r("p",[a._v("单行注释、多行注释、文档注释")]),a._v(" "),r("h2",{attrs:{id:"java八种基本类型"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#java八种基本类型"}},[a._v("#")]),a._v(" Java八种基本类型")]),a._v(" "),r("p",[a._v("byte short int long float double boolean char")]),a._v(" "),r("h2",{attrs:{id:"面向对象和面向过程的区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#面向对象和面向过程的区别"}},[a._v("#")]),a._v(" 面向对象和面向过程的区别")]),a._v(" "),r("p",[a._v("面向对象：将构成的问题拆分成对象，建立对象的目的不是为了完成一个个的步骤，而是为了描述某个事物在解决问题的过程中的方法。"),r("br"),a._v("\n面向过程：将构成的问题分成一步步的步骤，然后用函数把这些步骤一次次的实现。")]),a._v(" "),r("h2",{attrs:{id:"重载和重写区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#重载和重写区别"}},[a._v("#")]),a._v(" 重载和重写区别")]),a._v(" "),r("p",[a._v("重写发生在不同类中，子类继承父类所有的方法，但是有时候子类并不想原封不动的继承父类中的某个方法，所以在方法名、参数列表、返回类型相同的情况下，对方法体中对内容进行修改。"),r("br"),a._v("\n重载发生在同一类中，方法名必须相同，参数类型、个数、顺序至少有一个不相同。构造方法就是重载的一种形式。")]),a._v(" "),r("h2",{attrs:{id:"成员变量和局部变量的区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#成员变量和局部变量的区别"}},[a._v("#")]),a._v(" 成员变量和局部变量的区别")]),a._v(" "),r("p",[a._v("语法上：成员变量是属于类的，局部变量是在代码块或者方法中定义的变量，或者是方法的参数。"),r("br"),a._v("\n成员变量可以被public protected private static所修饰，但是局部变量不能被访问控制修饰符所修饰，但是成员变量和局部变量都可以被final所修饰。"),r("br"),a._v("\n存储方式，如果成员变量使用static所修饰，那么这个成员变量是属于类的，如果没有使用static所修饰，那么这个成员变量是属于实例的。对象存储在堆内存中，局部变量存储在栈内存中。"),r("br"),a._v("\n默认值，成员变量如果没有被赋予初始值，自动会设置一个初始值，而局部变量不会。")]),a._v(" "),r("h2",{attrs:{id:"对象的相等和引用的相等的区"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#对象的相等和引用的相等的区"}},[a._v("#")]),a._v(" 对象的相等和引用的相等的区")]),a._v(" "),r("p",[a._v("对象的相等一般是比较内存中存放的内容是否是相等的。"),r("br"),a._v("\n引用的相等一般是比较他们指向的地址是否是相等的。")]),a._v(" "),r("h2",{attrs:{id:"面向对象的三大特征"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#面向对象的三大特征"}},[a._v("#")]),a._v(" 面向对象的三大特征")]),a._v(" "),r("p",[a._v("封装：所谓封装：将具体的细节隐藏在了对象的内部，不允许外部直接访问，但是对外提供一些方法可以操作其内容，就好像我们属性都是私有化，方法公开化的样子。"),r("br"),a._v("\n继承：在实际开发中类和类中会存在一些共同的特性，比如猫和狗都是动物，他们都有一定的共同点，比如说都是动物。"),r("br"),a._v("\n多态：多态其实分为两种："),r("br"),a._v("\n1.同一类型的引用指向了不同的对象，就有不同的实现。"),r("br"),a._v("\n2.每一个对象都是多态的，间接或者直接的继承了Object")]),a._v(" "),r("h2",{attrs:{id:"和equals-的区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#和equals-的区别"}},[a._v("#")]),a._v(" ==和equals()的区别")]),a._v(" "),r("p",[a._v("==对于基本类型来说，==是比较的是值。"),r("br"),a._v("\n对于引用类型来说，==比较的对象的内存地址。"),r("br"),a._v("\nequals()不能用于判断基本类型的变量，只能用于判断两个对象是否相等。"),r("br"),a._v("\n类如果没有重写equals()方法，等价于==比较两个对象。"),r("br"),a._v("\n类如果重写了equals()方法，那么就是比较对象中的属性是否相等。")]),a._v(" "),r("h2",{attrs:{id:"string、stringbuffer、stringbuilder三者的区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#string、stringbuffer、stringbuilder三者的区别"}},[a._v("#")]),a._v(" String、StringBuffer、StringBuilder三者的区别")]),a._v(" "),r("p",[a._v("StringBuffer和StringBuilder都继承自抽象类AbstractStringBuilder。"),r("br"),a._v("\nString 声明的是不可变的对象，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象。"),r("br"),a._v("\nStringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。"),r("br"),a._v("\nStringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。")]),a._v(" "),r("p",[a._v("补充：String类型常用的方法"),r("br"),a._v("\nindexOf()：返回指定字符的索引。"),r("br"),a._v("\ncharAt()：返回指定索引处的字符。"),r("br"),a._v("\nreplace()：字符串替换。"),r("br"),a._v("\ntrim()：去除字符串两端空白。"),r("br"),a._v("\nsplit()：分割字符串，返回一个分割后的字符串数组。"),r("br"),a._v("\ngetBytes()：返回字符串的 byte 类型数组。"),r("br"),a._v("\nlength()：返回字符串长度。"),r("br"),a._v("\ntoLowerCase()：将字符串转成小写字母。"),r("br"),a._v("\ntoUpperCase()：将字符串转成大写字符。"),r("br"),a._v("\nsubstring()：截取字符串。"),r("br"),a._v("\nequals()：字符串比较。")]),a._v(" "),r("h2",{attrs:{id:"深拷贝和浅拷贝"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#深拷贝和浅拷贝"}},[a._v("#")]),a._v(" 深拷贝和浅拷贝")]),a._v(" "),r("p",[a._v("浅拷贝：拷贝对象和原始对象的引用类型都是同一个对象"),r("br"),a._v("\n深拷贝：拷贝对象和原始对象的应用类型不是同一个对象")]),a._v(" "),r("h2",{attrs:{id:"java的异常"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#java的异常"}},[a._v("#")]),a._v(" Java的异常")]),a._v(" "),r("p",[a._v("所有的异常都有一个祖先，Throwable类，Throwable有两个重要的子类，一个是Exception（表示需要捕捉或者处理的异常包含了运行时异常或者是非运行时异常）另外一个说Error（表示系统级的错误或者程序不必处理的异常）。"),r("br"),a._v("\n异常的处理："),r("br"),a._v("\n1.捕获异常try-catch-finally"),r("br"),a._v("\n2.抛出异常"),r("br"),a._v("\nThrow 是对外主动抛出一个异常，\nThorws是在方法上声明异常的抛出，此时调用的方法必须出该异常，否则编译不通过。\n常见的异常："),r("br"),a._v("\n(1)java.lang.NullPointerException 空指针异常，出现原因：调用了未经初始化的对象或者不存在的对象。"),r("br"),a._v("\n(2)ClassNoFoundException 指定类找不到，出现原因：类的名称和路径加载错误，通常是试图通过字符串来加载某个类时可能引发异常。"),r("br"),a._v("\n(3)NumberFormatException 字符串转换为数字异常，出现原因：字符串数据中包含非数字型字符。\n(4)IndexOutOfBoundsException 数组下标越界异常"),r("br"),a._v("\n(5)IllegalArgumentException 方法传递参数错误"),r("br"),a._v("\n(6)ClassCastException 数据类型转换异常"),r("br"),a._v("\n(7)NoClassDefFoundExcetion 未找到类定义错误"),r("br"),a._v("\n(8)SQLException SQL 异常"),r("br"),a._v("\n(9)InstantiationException 实例化异常"),r("br"),a._v("\n(10)NoSuchMethodExceptioin 方法不存在异常")]),a._v(" "),r("h2",{attrs:{id:"范型"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#范型"}},[a._v("#")]),a._v(" 范型")]),a._v(" "),r("p",[a._v("范型是参数化类型，允许我们在使用一个类的时候指定它的属性的类型，方法的参数，返回值的类型，使用的时候可以更加的灵活。有范型类，范型接口，范型方法，范型在集合中广泛使用。")]),a._v(" "),r("h2",{attrs:{id:"io流"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#io流"}},[a._v("#")]),a._v(" IO流")]),a._v(" "),r("p",[a._v("IO流可以让我们用标准的读写操作来完成不同设备的读写数据。"),r("br"),a._v("\nIO即Input/output输入和输出。"),r("br"),a._v("\nIO流大方向可以分为输入流和输出流。"),r("br"),a._v("\n字节流：InputStream（输入流）OutputStream（输出流）"),r("br"),a._v("\n字符流：Reader（输入流）Writer（输出流）"),r("br"),a._v("\nIO流也可以分为低级流和高级流流"),r("br"),a._v("\n低级流：文件流"),r("br"),a._v("\nFileInputStream（文件输入流）FileOutputStream（文件输出流）"),r("br"),a._v("\n高级流：缓冲输入/输出流、对象输入/输出流等"),r("br"),a._v("\nBufferedInputStream、BufferedOutputstream"),r("br"),a._v("\nBufferReader、BufferWriter"),r("br"),a._v("\nObjectInputStream、ObjectOutputStream"),r("br"),a._v("\nInputStreamReader、OutputStreamWriter"),r("br"),a._v("\nPrintWriter")]),a._v(" "),r("h2",{attrs:{id:"对接第三方接口需要考虑什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#对接第三方接口需要考虑什么"}},[a._v("#")]),a._v(" 对接第三方接口需要考虑什么")]),a._v(" "),r("p",[a._v("1.确认接口对接的网络协议 https/http"),r("br"),a._v("\n2.约定好数据传参、响应格式等"),r("br"),a._v("\n3.接口安全方面，确定身份校验方式，使用token、证书校验等"),r("br"),a._v("\n4.确认是否需要接口调用失败后重试机制，保证数据传输等最终一致性"),r("br"),a._v("\n4.日志记录要全面")]),a._v(" "),r("h2",{attrs:{id:"接口和抽象类的区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#接口和抽象类的区别"}},[a._v("#")]),a._v(" 接口和抽象类的区别")]),a._v(" "),r("p",[a._v("相同处："),r("br"),a._v("\n1.不能够实例化"),r("br"),a._v("\n不同处："),r("br"),a._v("\n1.抽象类使用abstract关键字声明 接口使用interface关键字声明"),r("br"),a._v("\n2.抽象类可以定义构造器 接口中不能定义构造器"),r("br"),a._v("\n3.抽象类中可以定义成员变量 接口中不能定义成员变量"),r("br"),a._v("\n4.抽象类中可以有普通方法可以抽象方法  接口中全部都是抽象方法"),r("br"),a._v("\n5.抽象类中的方法可以是任意访问修饰符(public private protected) 接口中默认是public的"),r("br"),a._v("\n6.一个类只能继承一个抽象类 一个类可以实现多个接口")]),a._v(" "),r("h2",{attrs:{id:"final关键字的用法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#final关键字的用法"}},[a._v("#")]),a._v(" final关键字的用法")]),a._v(" "),r("p",[a._v("(1)修饰类：表示该类不能被继承；"),r("br"),a._v("\n(2)修饰方法：表示方法不能被重写；"),r("br"),a._v("\n(3)修饰变量：表示变量只能一次赋值以后值不能被修改（常量）。")]),a._v(" "),r("h2",{attrs:{id:"static和final的区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#static和final的区别"}},[a._v("#")]),a._v(" static和final的区别")]),a._v(" "),r("p",[r("strong",[a._v("static")]),a._v(":"),r("br"),a._v("\nstatic修饰变量：也就是类变量，在类加载时被创建并初始化。"),r("br"),a._v("\nstatic修饰方法：静态方法，通过类名.方法名直接访问。静态方法不能直接访问本类中非静态成员（方法和属性）"),r("br"),a._v(" "),r("strong",[a._v("final")]),a._v(":"),r("br"),a._v("\nfinal可以修饰变量 修饰的变量就是常量 一旦赋值不能被修改"),r("br"),a._v("\nfinal可以修饰方法 不能被子类覆盖"),r("br"),a._v("\nfinal可以修饰类 不能被继承")]),a._v(" "),r("h2",{attrs:{id:"反射"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#反射"}},[a._v("#")]),a._v(" 反射")]),a._v(" "),r("p",[a._v("动态获取的信息以及动态调用对象的方法功能称为Java语言的反射机制。"),r("br"),a._v("\n在运行状态中，对于任意一个类，能够知道这个类的所有属性和方法。对于任意一个对象，能够调用它的任意一个方法和属性。")]),a._v(" "),r("p",[a._v("平时写业务代码很少直接使用反射机制，但是不代表没有，像Spring/Spring boot/Mybaits等框架都大量使用了反射机制。")]),a._v(" "),r("p",[a._v("获取Class对象的四种方式"),r("br"),a._v("\n1.类名.class"),r("br"),a._v("\n2.通过Class.forName()传入类的全路径获取"),r("br"),a._v("\n3.通过对象的实力instance.getClass()获取"),r("br"),a._v("\n4.通过类加载器ClassLoader.loadClass()传入类路径")]),a._v(" "),r("p",[a._v("通过反射创建进行对象的实例化（有参和无参）")]),a._v(" "),r("div",{staticClass:"language-java extra-class"},[r("pre",{pre:!0,attrs:{class:"language-java"}},[r("code",[a._v("    "),r("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//待补充")]),a._v("\n")])])]),r("p",[a._v("通过反射机制进行对象方法的调用（有参和无参）invoke")]),a._v(" "),r("div",{staticClass:"language-java extra-class"},[r("pre",{pre:!0,attrs:{class:"language-java"}},[r("code",[a._v("    "),r("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//待补充")]),a._v("\n")])])]),r("h2",{attrs:{id:"cookie和session的区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#cookie和session的区别"}},[a._v("#")]),a._v(" Cookie和Session的区别")]),a._v(" "),r("p",[a._v("Cookie和session都是用于在Web应用程序中管理状态和数据的机制，但它们有以下区别：")]),a._v(" "),r("ol",[r("li",[a._v("存储位置：Cookie是存储在客户端（浏览器）中，而Session是存储在服务器端的内存或磁盘中。")]),a._v(" "),r("li",[a._v("数据大小：Cookie的数据大小有限制，最大只能为4KB，而Session的数据大小没有限制。")]),a._v(" "),r("li",[a._v("安全性：Cookie的数据容易被窃取和篡改，因为它存储在客户端，而Session的数据存储在服务器端，相对来说更加安全。")]),a._v(" "),r("li",[a._v("生命周期：Cookie可以设置过期时间，存储在客户端中的时间是有限制的，而Session的生命周期是由服务器控制的，一般会在一段时间后自动失效。")]),a._v(" "),r("li",[a._v("使用范围：Cookie可以在同一浏览器的不同页面之间共享，而Session只能在同一服务器上的不同页面间共享。"),r("br"),a._v("\n总之，Cookie和Session都有各自的优缺点，开发人员应根据实际需求选择适合的机制来管理状态和数据。")])]),a._v(" "),r("h2",{attrs:{id:"get请求和post请求的区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#get请求和post请求的区别"}},[a._v("#")]),a._v(" GET请求和POST请求的区别：")]),a._v(" "),r("ol",[r("li",[a._v("GET请求将所有的请求参数都放在URL中，而POST请求将请求参数放在请求体中。因此，GET请求的URL中会包含请求参数，而POST请求的URL中不会包含请求参数。")]),a._v(" "),r("li",[a._v("GET请求的请求体为空，而POST请求的请求体中包含请求参数。")]),a._v(" "),r("li",[a._v("GET请求不安全，因为请求参数暴露在URL中，容易被他人看到、窃取或篡改请求参数，而POST请求比较安全，因为请求参数放在请求体中，不容易被他人看到和篡改。")]),a._v(" "),r("li",[a._v("GET请求的数据传输量有限制，由于请求参数包含在URL中，URL的长度有限制，一般是2048个字符，因此GET请求传输的数据量有限制。而POST请求的数据传输量没有明确的限制，理论上可以传输任意大小的数据。"),r("br"),a._v("\n一般来说，GET请求常用于获取资源、查询数据等场景，而POST请求常用于提交表单、上传文件、修改数据等场景。需要根据实际的业务需求选择合适的请求方式。")])])])}),[],!1,null,null,null);r.default=s.exports}}]);